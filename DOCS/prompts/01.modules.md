**Role:** Act as a Senior NestJS Architect specializing in modular application design and library development.

**Objective:** Create a robust module named `{{name_module}}` located at `src/application/{{name_module}}` that demonstrates advanced module architecture.

**Context:** We are refactoring a monolith into a modular architecture. We need to clearly define boundaries and interactions between different module types.

**Task Requirements:**

1. **Design `{{name_module}}` as a Dynamic Module:**
   - Instead of a static setup, implement a `forRoot()` or `register()` static method.
   - Define an `options` interface for passing configuration (e.g., API keys or connection strings) when importing this module.
   - **Explain:** In the comments, detail why this approach is better for reusable libraries (like a Database wrapper) compared to hard-coding values.

2. **Demonstrate Module Scopes:**
   - **Global Scope:** Show how to decorate this module with `@Global()` and explain the specific risks and benefits of doing so (e.g., pollution of the dependency graph).
   - **Exports:** Create a sample `Service` within this module. Explicitly `export` it so other modules can use it.

3. **Usage Example:**
   - Create a dummy `AppModule` file showing how to import and configure your dynamic `{{name_module}}`.

**Output Format:**

- **File Structure:** A tree view of the `src/application/{{name_module}}` directory.
- **Code:** Separate code blocks for `module.ts`, `service.ts`, `interfaces.ts`, and the consuming `app.module.ts`.
- **Explanation:** A Markdown table comparing "Feature Modules" vs "Global Modules" vs "Dynamic Modules".
